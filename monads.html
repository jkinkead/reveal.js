<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Monads in Scala</title>

    <meta name="description" content="">
    <meta name="author" content="Jesse Kinkead">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple_white.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Monads in Scala</h2>
          <p>What are Monads, and how they're useful in Scala.</p>
          <p class="fragment">Spoiler alert: I'm going to mostly gloss over Monad details.</p>
        </section>

        <section>
          <section>
            <h2>What is a monad?</h2>
            <p>A monad is a container that supports a specific set of operations.</p>
          </section>
          <section>
            <h3>If you want to read more, <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">Wikipedia has you covered.</a></h3>
            <p>I don't recommend this, as it's extremely technical, and all the examples are in Haskell.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Simply: Monads are parameterized types</h2>
            <p>Because monads are containers, they will be parameterized in the type they contain.</p>
            <p>In Scala scala terms, they will be a class or trait with a type parameter.</p>
          </section>
          <section>
            <h3>"Monadic" Scala</h3>
            <p>I'll be covering monads as a code pattern; what I'm calling "monadic" classes.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Basic operations</h2>
            <p>There are two required operations that make up a monad: a constructor ("return") and a map function ("bind").</p>
            <p>For the next few slides, I'll use the type <code>Mon[T]</code>:</p>
<pre><code class="scala">
// TODO: Make me monadic!
class Mon[T]

object Mon

</code></pre>
          </section>
          <section>
            <h3>Constructor</h3>
            <p>Construction can be thought of as wrapping a value. In scala, this is generally an <code>apply</code> method:</p>
<pre><code class="scala">
class Mon[T](wrapped: T)

object Mon {
  def apply[T](value: T) = new Mon(value)
}

val unwrapped: Int = 123
// Usually called like: Mon(123)
val wrapped: Mon[Int] = Mon.apply(123)

</code></pre>
          </section>
          <section>
            <h3>Mapping function</h3>
            <p>Formally, a monadic mapping is a function that takes two arguments - <code>Mon[T]</code>, and a function from <code>T</code> to <code>Mon[U]</code> - and returns <code>Mon[U]</code>.</p>
            <p> In Scala, we call the formal "bind" <code>flatMap</code>, but usually use the more convenient <code>map</code> function.</p>
          </section>
          <section>
            <h3>Example <code>map</code></h3>
<pre><code class="scala">
class Mon[T](wrapped: T) {
  /** Run the given operation, and return the Mon wrapping
    * the result.
    */
  def map[U](operation: T => U): Mon[U] = {
    Mon(operation(wrapped))
  }
}

val five: Mon[Int] = Mon(5)
val ten: Mon[Int] = five map { _ * 2 }

</code></pre>
          </section>
          <section>
            <h3>Example <code>flatMap</code></h3>
<pre><code class="scala">
class Mon[T](wrapped: T) {
  /** Run the given operation, and return resulting Mon. */
  def flatMap[U](operation: (T => Mon[U]): Mon[U] = {
    operation(wrapped)
  }
}

val five: Mon[Int] = Mon(5)
val ten: Mon[Int] = five map { value => Mon(value * 2) }

</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>And now, a short refresher on functions.</h2>
            <p class="fragment">Or, understanding the difference between <code>Function</code> and <code>PartialFunction</code>.</p>
          </section>
          <section>
            <h3>Functions as parameters</h3>
            <p>The type signature of a function that takes an argument of type <i>T</i> and
            returns an argument of type <i>U</i> is <code>T =&gt; U</code>.</p>
<pre><code class="scala">
// From the earlier slide.
class Mon[T](wrapped: T) {
  def map[U](operation: T => U): Mon[U] = {
    Mon(operation(wrapped))
  }
}

</code></pre>
          </section>
          <section>
            <h3>Call-by-name functions</h3>
            <p>You may also see the type <code>=&gt; U</code>. This is a special type of function called "call-by-name".</p>
<pre><code class="scala">
/** Runs the given code in one second. */
def delayedRun[U](operation: => U): U = {
  Thread.sleep(1000)
  operation
}

def printTime() = println(s"Now = ${System.currentTimeMillis}")
// The compiler automatically converts the argument to a function.
delayedRun(printTime())

</code></pre>
          </section>
          <section>
            <h3>Function literals</h3>
<pre><code class="scala">
// This is of type Int => String.
val intToString = { i: Int => i.toString }

// Types can be inferred as well, as it would be in a parameter.
val intToLong: Int => Long = { i => i.toLong }

// You can also bind existing functions with `_`.
val intToFloat: Int => Float = Int.int2float _

</code></pre>
          </section>
          <section>
            <h3>Partial functions</h3>
            <p>Partial functions are used occasionaly in APIs</p>
            <p>They are also a subclass of <code>Function</code>, so you can
            use them in any API that wants a regular function.</p>
          </section>
          <section>
            <h3>Partial function literals</h3>
<pre><code class="scala">
// Looks just like the body of a match statement:
val toEvennessString: PartialFunction[Int, String] = {
  case x if x % 2 == 0 => "even"
  case _ => "odd"
}

</code></pre>
            <div class="fragment">
              <p>Important caveat:</p>
              <p>An API that takes <code>Function</code> will throw an exception if the partial doesn't match the input.</p>
            </div>
          </section>
        </section>

        <section>
          <section>
            <h2>Case study: <code>scala.Option</code></h2>
            <p>This is the canonical example of a monad, and replaces the <code class="scala">null</code> of other programming languages.</p>
            <p class="fragment">. . . although Scala still supports <code class="scala">null</code>.</p>
          </section>
          <section>
            <h3>Chaining operations with <code>Option</code></h3>
            <p><code>map</code> nicely replaces checks against <code>null</code>:</p>
<pre><code class="scala">
// With null:
var maybeNull: String = _
val derived: String = if (maybeNull != null) {
  maybeNull + " - not null!"
} else {
  null
}

// With Option:
var maybeNone: Option[String] = _
val derived: Option[String] = maybeNone map { _ + " - not null!" }

</code></pre>
            <p class="fragment">Notice how the option-ness is captured in the type! This means you can ditch null-checks in your functions.</p>
          </section>
          <section>
          <h3>Thinking <code>Option</code>ally (1/2)</h3>
            <p>You can write functions that operate on regular values, and <code>map</code> your options onto them.</p>
<pre><code class="scala">
// With null:
var maybeNull: String = _
def takesMaybeNull(param: String): String = {
  if (param == null) { "default" } else { "I got: " + param }
}
takesMaybeNull(maybeNull)

// With Option:
var maybeNone: Option[String] = _
def takesNonOption(param: String): String = "I got: " + param
maybeNone map { takesNonOption } getOrElse { "default" }

</code></pre>
          </section>
          <section>
            <h3>Thinking <code>Option</code>ally (2/2)</h3>
            <p>Notice how that moved error handling to the caller!</p>
            <p>This is usually easier to understand - functions are smaller, and edge-cases are handled closer to where the data was generated.</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Other tricks with <code>Option</code></h2>
            <p>Scala has some useful extensions to their monadic types.</p>
            <p>For <code>Option</code>, these come from <code>scala.collection.Iterable</code>.</p>
          </section>
          <section>
            <h3><code>zip</code> - combine two values</h3>
            <p>Zipping <code>Option[T]</code> with <code>Option[U]</code> gives <code>Iterable[(T, U)]</code>, with one or zero values.</p>
            <p>This lets you execute code (or return a value) if and only if two options are non-None:</p>
<pre><code class="scala">
def doStuff(
  option1: Option[String],
  option2: Option[String]
): Option[String] = {
  val result: Iterable[String] = option1 zip option2 map {
    case (value1, value2) => value1 + " && " + value2
  }
  // Convert back to Option.
  result.headOption
}

</code></pre>
          </section>
          <section>
            <h3><code>Option</code> is an <code>Iterable</code> (1/3)</h3>
            <p>This is a lie - <code>Option</code> instead has an implicit conversion - but it does implement all of the <i>methods</i> in <code>Iterable</code>.</p>
            <p>This means you can append an <code>Option</code> to another <code>Iterable</code>:</p>
<pre><code class="scala">
val mySeq = Seq.empty[String]
var optionalValue: Option[String] = _

// Here, we're appending all values in the Iterable `optionalValue`.
// This has zero entries if it's None, one entry if it's Some.
val newSeq = mySeq ++ optionalValue

</code></pre>
          </section>
          <section>
            <h3><code>Option</code> is an <code>Iterable</code> (2/3)</h3>
            <p>You can also flatten iterables of options:</p>
<pre><code class="scala">
val seqOfOptions: Seq[Option[String]] =
  Seq(Some("one"), None, None, Some("four"), None)

// `flatSeq` is Seq("one", "four").
val flatSeq: Seq[String] = seqOfOptions.flatten

</code></pre>
          </section>
          <section>
            <h3><code>Option</code> is an <code>Iterable</code> (3/3)</h3>
            <p>Finally, you can use <code>flatMap</code> with another iterable to append only non-None values to your list:</p>
<pre><code class="scala">
val integers = 1 until 10

// `lowPrimesAsString` is Seq("2", "3", "5", "7").
val lowPrimesAsString = integers flatMap {
  case prime @ (2 | 3 | 5 | 7) => Some(prime.toString)
  case _ => None
}

</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Case study: <code>scala.concurrent.Future</code></h2>
            <p><code>Future</code> abstracts away running code in another thread.</p>
            <aside class="notes">This is a more classic monad: Using <code>Future[T]</code> means that your mapping functions produce a side-effect (being run in a separate thread).</aside>
          </section>
          <section>
            <h3>A note on how <code>Future</code> works</h3>
            <p>Any time you call a function that creates a new instance of <code>Future</code>, you need to pass in an implicit <code>scala.concurrent.ExecutionContext</code></p>
            <p>For all practical purposes, this can be thought of as the pool of threads that will run your asynchronous code. See
              <a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.ExecutionContext">the ExecutionContext Scaladoc</a> for more info.</p>
          </section>
        </section>

        <section>
          <section>
            <h2><code>Future</code>-minded thinking</h2>
            <p>As expected, the basic operations on <code>Future</code> are <code>map</code> and <code>flatMap</code>. Note that all
            example code assumes an implicit ExecutionContext is in scope.</p>
<pre><code class="scala">
// A future that returns a string.
val futureString: Future[String] = Future {
  "I'm running in the future! :D"
}

// Here we have a future with a side-effect, and no return type.
val futurePrint: Future[Unit] = futureString map { string =>
  println(s"I got a message from the future: $string")
}

</code></pre>
          </section>
          <section>
            <h3>Nested <code>Future</code></h3>
            <p>Once you start going down the <code>Future</code> rabbit hole, you may need to have a <code>Future</code>
            returning a <code>Future</code>. This is what <code>flatMap</code> is for:</p>
<pre><code class="scala">
val futureOne: Future[String] = Future { "roads" }

val futureTwo: Future[String] = futureOne flatMap { result =>
  Future { "Where we're going, we don't need " + result }
}

</code></pre>
          </section>
          <section>
            <h3>Handling multiple <code>Futures</code></h3>
<pre><code class="scala">
// If you have a sequence of Futures, you can "unwrap" them with
// Future.sequence.
val numberFutures: Seq[Future[String]] = 1 to 10 map { number =>
  Future { number.toString }
}
val futureOfNumbers: Future[Seq[String]] = {
  Future.sequence(numberFutures)
}

// Two Futures can be zipped together, just like with Option.
val futureOne: Future[String] = Future { "one" }
val futureTwo: Future[String] = Future { "two" }
val futureThree: Future[(String, String)] = futureOne zip futureTwo

</code></pre>
          </section>
          <section>
            <h3>Immediate values</h3>
            <p>Sometimes, you'll need a <code>Future</code>, but already know the value it will return.</p>
<pre><code class="scala">
val extraWorkResult: Future[Option[String]] = {
  if (doExtraWork) {
    // Run in another thread.
    Future(Some(extraWork()))
  } else  {
    // No need to run in another thread.
    Future.successful(None)
  }
}

</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Checking the result of your <code>Future</code></h2>
            <p>Operations that work on <code>Future</code> results fall into two categories: Those that return a new <code>Future</code> (map and recovery functions), and those that return <code>Unit</code> (side-effect functions).</p>
            <p>We already saw how mapping functions work.</p>
          </section>
          <section>
            <h3>Recovery functions: <code>recover</code> and <code>recoverWith</code> (1/2)</h3>
            <p>These two functions let you catch exceptions, and are used where you'd normally use a <code class="scala">catch</code> block.</p>
<pre><code class="scala">
// Throws an exception half of the time.
def randomFuture: Future[String] = Future {
  val even = System.currentTimeMillis / 1000 % 2 == 0
  if (even) { "even" } else { throw new Exception("odd") }
}

// Recover from randomly thrown exceptions.
val recovered: Future[String] = randomFuture recover {
  case e: Exception if e.getMessage == "odd" => {
    "sorry, we rolled odd"
  }
}

</code></pre>

          </section>
          <section>
            <h3>Recovery functions: <code>recover</code> and <code>recoverWith</code> (2/2)</h3>
            <p>The difference between these is similar to the difference between <code>map</code> and <code>flatMap</code>.</p>
<pre><code class="scala">
// recoverWith expects you to return a Future instead of a regular value.
val recovered: Future[String] = randomFuture recoverWith {
  case e: Exception if e.getMessage == "odd" => {
    // Identical except for the below:
    Future { "sorry, we rolled odd" }
  }
}

</code></pre>
          </section>
          <section>
          <h3>Side-effect functions: <code>onComplete</code>, <code>onFailure</code>, <code>onSuccess</code></h3>
            <p>These are straightforward: <code>onComplete</code> looks at the full result (success or failure), while <code>onSuccess</code> and <code>onFailure</code> only look at their respective result.</p>
<pre><code class="scala">
randomFuture onComplete {
  case Success(_) => println("even!")
  case Failure(_) => println("odd!")
}

randomFuture onSuccess { case _: String => println("even!") }
randomFuture onFailure { case _: Exception => println("odd!") }

</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Monads in the wild</h3>
            <p>Once you understand how Scala's monadic type work, you'll start seeing them crop up in other libraries.</p>
          </section>
          <section>
            <h2>Case study: Monadic operations in Slick</h2>
            <p>We use <a href="http://slick.typesafe.com/">Slick</a> at AI2 for relational database access.</p>
            <p>Slick uses two monadic types: Query and DBIO.</p>
          </section>
          <section>
            <h3>Short example (<code>Query</code>)</h3>
<pre><code class="scala">
// Queries represent single SQL statements, and have
// some iterable-like operations.
// I've left off the type because it's complicated, but it encodes
// the table(s) you're selecting from, the result value type(s),
// and whether this will return rows or a single value.
val query = myTable filter { _.id === 1 }

// Supports chaining and mapping.
query filter { _.name === "some name" } map { _.cost }

</code></pre>
          </section>
          <section>
          <h3>Short example (<code>DBIO</code>)</h3>
<pre><code class="scala">
// DBIOs represent the result of running a statement, and
// act like Futures.
val dbio: DBIO[Int] = query.result map { _.id }

// They support map, flatMap, zip, and DBIO.sequence, all
// analogous to the Future type.
val dbio: DBIO[Int] = query.result map { _.id } flatMap { id =>
  someTable.filter(_.id === id).result
}

</code></pre>
          </section>
        </section>
        <section>
          <h3>Conclusion: Monadic code can be your friend</h3>
          <div class="fragment">
            <p>Now go write some Haskell.</p>
            <p><a href="http://jkinkead.github.io/reveal.js/monads.html">Link to these slides</a></p>
          </div>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>
  </body>
</html>
